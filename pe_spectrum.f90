!
! Last modified: Jan 8, 2009
! Original author: Serguei.Patchkovskii@nrc.ca
!
!  Simulate a photoelectron spectrum of a polyatomic molecule, using
!  precomputed Franck-Condon factors and dipole photoionization 
!  matrix elements.
!
!  Franck-Condon factors can be generated by "franck_condon.x" program
!
!  Dipole matrix elements can be generated by "amplitudes.x" program
!
!  The approach uses expressions based on problem 186 of S. Fluegge,
!  "Practical Quantum Mechanics", Springer, 1971. See "photoionization-fc.pdf"
!  for derivation of the expressions.
!
! Revision history:
!
!  Jan 8, 2009 - Initial version
!
  module pe_spectrum
    use accuracy
    use timer
    private
    public photoelectron_spectrum
    !
    integer(ik)           :: unit_scr        = 40      ! Any unused unit
    integer(ik)           :: verbose         = 0       ! Verbosity level
    integer(ik)           :: n_electronic    = 0       ! Number of electronic transition probabilities
    integer(ik)           :: n_nuclear       = 0       ! Number of vibrational transitions
    character(len=80)     :: file_electronic = ' '     ! Name of the file containing electronic transition data
    character(len=80)     :: file_nuclear    = ' '     ! Name of the file containing vibrational factors
    real(rk)              :: excess_e        = 5._rk   ! Excess photon energy above the vibrational origin, eV
    real(rk)              :: line_width      = 0.01_rk ! Natural line half-width at half-height, eV
    real(rk)              :: e_min           = 0.1_rk  ! Min. photoelectron energy, eV
    real(rk)              :: e_max           = 5.0_rk  ! Max. photoelectron energy, eV
    real(rk)              :: e_step          = 0.01_rk ! Step in photoelectron energy
    real(rk), allocatable :: p_electronic(:,:)      ! Electronic transition probabilities.
                                                    ! The first index is:
                                                    !   1: continuum electron energy in Hartree
                                                    !   2: probability, integrated over orientations
                                                    ! Entries are sorted in the order of the increasing energy
    real(rk), allocatable :: p_nuclear(:,:)         ! Vibrational transition probabilities (squares of the
                                                    ! Franck-Condon overlaps). The first index is:
                                                    !   1: relative vibrational energy of the final state in Hartree
                                                    !   2: probability.
                                                    ! Entries can be in any order
    integer(ik)           :: n_spec                 ! Number of points in the simulated spectrum
    real(rk),allocatable  :: spec(:,:)              ! Simulated spectrum. The first index is:
                                                    !   1: Energy in Hartree
                                                    !   2: Cross-section (see notes and below for the units)
    !
    namelist /pe_par/                    &
      verbose,                           &
      n_electronic, file_electronic,     &
      n_nuclear, file_nuclear,           &
      excess_e, line_width,              &
      e_min, e_max, e_step
 
    !
    contains
    !
    subroutine load_franck_condon
      character(len=80)  :: action
      integer(ik)        :: ios, line, ip
      real(rk)           :: amp, e1, e0
      real(rk)           :: sum
      !
      line = 0
      input_block: do
        action = 'opening'
        open(unit_scr,file=trim(file_nuclear),form='formatted',action='read',status='old',iostat=ios)
        if (ios/=0) exit input_block
        action = 'reading'
        !
        sum = 0._rk
        read_fc_lines: do ip=1,n_nuclear
          line = line + 1
          read(unit_scr,*,iostat=ios) amp, e1, e0
          if (ios/=0) exit input_block
          ! 
          !  Convert amplitudes to probabilities, and cm^-1 to Hartrees
          !
          p_nuclear(1,ip) = (e1-e0)/h2cm
          p_nuclear(2,ip) = amp**2
          sum = sum + p_nuclear(2,ip)
        end do read_fc_lines
        !
        if (verbose>=0) then
          write (out,"(/'Sum of squares of the FC factors is ',g15.9)") sum
        end if
        !
        action = 'closing'
        close(unit_scr,iostat=ios)
        return
      end do input_block
      write (out,"('Error ',i5,' while ',a,' file ',a,' at line ',i8)") ios, trim(action), trim(file_nuclear), line
      stop 'pe_spectrum%load_franck_condon'
    end subroutine load_franck_condon
    !
    subroutine load_electronic_dipoles
      character(len=80)  :: action
      integer(ik)        :: ios, line, ip
      real(rk)           :: ekin, p
      !
      line = 0
      input_block: do
        action = 'opening'
        open(unit_scr,file=trim(file_electronic),form='formatted',action='read',status='old',iostat=ios)
        if (ios/=0) exit input_block
        action = 'reading'
        !
        read_dip_lines: do ip=1,n_electronic
          line = line + 1
          read(unit_scr,*,iostat=ios) ekin, p
          if (ios/=0) exit input_block
          ! 
          !  Convert energies to Hartrees
          !
          p_electronic(1,ip) = ekin/h2ev
          p_electronic(2,ip) = p
        end do read_dip_lines
        !
        action = 'closing'
        close(unit_scr,iostat=ios)
        return
      end do input_block
      write (out,"('Error ',i5,' while ',a,' file ',a,' at line ',i8)") ios, trim(action), trim(file_electronic), line
      stop 'pe_spectrum%load_electronic_dipoles'
    end subroutine load_electronic_dipoles
    !
    subroutine initialize_spectrum
      integer(ik) :: ipt
      !
      fill_spectrum: do ipt=1,n_spec
        spec(1,ipt) = (e_min + ((e_max-e_min)*(ipt-1))/(n_spec-1))/h2ev
        spec(2,ipt) = 0._rk
      end do fill_spectrum
    end subroutine initialize_spectrum
    !
    subroutine vibrational_spectrum
      integer(ik) :: itr
      real(rk)    :: ekin            ! Kinetic energy of the continuum electron
      integer(ik) :: is_low, is_high ! Points of the spectrum affected by this line
      integer(ik) :: is
      real(rk)    :: adj_w           ! Line half-width divided by sqrt(log(2))
      real(rk)    :: scl             ! Line scaling factor
      real(rk)    :: eps             ! Cut-off for the lines
      real(rk)    :: demax           ! Max. energy shift where tails of the natural energy distribution
                                     ! are still significant.
      !
      eps   = 1e-7_rk
      adj_w = (line_width/h2ev)/sqrt(log(2._rk))
      scl   = 1._rk / ( adj_w * sqrt(pi) )
      demax = adj_w * sqrt(-log(eps*adj_w*sqrt(pi)))
      if (verbose>=1) then
        write (out,"('Will trace lines to ',e11.5,' H (',e11.5,' eV) off-centre')") demax, demax*h2ev
      end if
      scan_transitions: do itr=1,n_nuclear
        ekin = excess_e/h2ev - p_nuclear(1,itr)
        if (ekin<=0) cycle scan_transitions ! Not enough energy to excite this mode
        !
        !  Figure out the range of affected positions in the spectrum
        !
        is_low  = max(1 + nint(((ekin - demax) - (e_min/h2ev))/(e_step/h2ev)),1)
        is_high = min(1 + nint(((ekin + demax) - (e_min/h2ev))/(e_step/h2ev)),n_spec)
        if (verbose>=2) then
          write (out,"('FC line ',i6,' at ',e11.5,' H (',e11.5,' cm-1) affects spectrum for ',2i6,' (',2e11.5,')')") &
                 itr, p_nuclear(1,itr), p_nuclear(1,itr)*h2cm, is_low, is_high, spec(1,is_low), spec(1,is_high)
        end if
        fill_spectrum: do is=is_low,is_high
          spec(2,is) = spec(2,is) + p_nuclear(2,itr) * scl * exp(-((spec(1,is)-ekin)/adj_w)**2)
        end do fill_spectrum
      end do scan_transitions
    end subroutine vibrational_spectrum
    !
    function interpolate_electronic(ekin) result(ef)
      real(rk), intent(in) :: ekin ! Kinetic energy of the continuum electron
      real(rk)             :: ef   ! Interpolated matrix element
      !
      integer(ik) :: ilow, ihigh, imid
      !
      ilow = 1 ; ihigh = n_electronic
      bisect_table: do while(ihigh-ilow>1)
        imid = (ihigh+ilow)/2
        if (p_electronic(1,imid)>=ekin) then
          ihigh = imid
        else
          ilow = imid
        end if
      end do bisect_table
      !
      if (verbose>=3) then
        write (out,"('E: ',e11.5,' <= ',e11.5,' <= ',e11.5)") p_electronic(1,ilow), ekin, p_electronic(1,ihigh)
      end if
      if (ekin>=p_electronic(1,ilow) .and. ekin<=p_electronic(1,ihigh)) then
        ef = p_electronic(2,ilow) + (p_electronic(2,ihigh)-p_electronic(2,ilow)) * &
                                    (ekin-p_electronic(1,ilow)) / &
                                    (p_electronic(1,ihigh)-p_electronic(1,ilow))
      else
        !
        !  Hit the edge - choose one of the limiting values
        !
        if (ekin<=p_electronic(1,ilow)) then
          ef = p_electronic(2,ilow)
        else
          ef = p_electronic(2,ihigh)
        end if
      end if
      if (verbose>=3) then
        write (out,"('F: ',e11.5,' <= ',e11.5,' <= ',e11.5)") p_electronic(2,ilow), ef, p_electronic(2,ihigh)
      end if
    end function interpolate_electronic
    !
    subroutine electronic_spectrum
      integer(ik) :: is
      real(rk)    :: kf, ef
      !
      scale_spectrum: do is=1,n_spec
        kf = sqrt(2*spec(1,is))
        ef = interpolate_electronic(spec(1,is))
        spec(2,is) = spec(2,is) * kf * ef
      end do scale_spectrum
    end subroutine electronic_spectrum
    !
    subroutine report_spectrum
      integer(ik) :: is
      !
      write (out,"()")
      write (out,"('Cross-sections are given in the units of (e^2 V m omega)/(2 pi c hbar^4), where')")
      write (out,"('e and m are electron charge and mass, V is the normalization volume, c is the')")
      write (out,"('speed of light, and omega is the circular frequency of the incident radiation')")
      write (out,"()")
      write (out,"('  ',a8,1x,a18)") 'Ekin,eV', 'Cross-section', &
                                     '-------', '-------------'
      print_lines: do is=1,n_spec
        write (out,"('@ ',f8.4,1x,e18.10)") h2ev*spec(1,is), spec(2,is)
      end do print_lines
      write (out,"()")
    end subroutine report_spectrum
    !
    subroutine photoelectron_spectrum
      integer(ik) :: info
       call TimerStart('Photoelectron spectrum')
       call accuracyInitialize
       !
       read(input,nml=pe_par,iostat=info)
       write (out,"(/'==== Simulation parameters ====')")
       write (out,nml=pe_par)
       write (out,"()")
       !
       n_spec = 1+(e_max-e_min)/e_step
       write (out,"('Simulated spectrum length = ',i9)") n_spec
       allocate (p_electronic(2,n_electronic),p_nuclear(2,n_nuclear),spec(2,n_spec),stat=info)
       if (info/=0) then
         write (out,"('Error ',i5,' in memory allocation.')") info
         stop 'pe_spectrum%photoelectron_spectrum - no memory'
       end if
       !
       call load_franck_condon
       !
       call load_electronic_dipoles
       !
       call initialize_spectrum
       !
       call vibrational_spectrum
       !
       call electronic_spectrum
       !
       call report_spectrum
       !
       write (out,"()")
       !
       call TimerStop('Photoelectron spectrum')
       call TimerReport
    end subroutine photoelectron_spectrum
  end module pe_spectrum
  !
  program run_pe
    use pe_spectrum
    !
    call photoelectron_spectrum
  end program run_pe
